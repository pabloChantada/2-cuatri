#Practica voluntaria:

using FileIO
using DelimitedFiles
using Statistics


function oneHotEncoding(feature::AbstractArray{<:Any,1}, classes::AbstractArray{<:Any,1})

    numClasses = length(classes);
    @assert(numClasses>1);
    if numClasses==2
        # Si solo hay dos clases, se devuelve una matriz con una columna.
        matriz_una_columna = reshape(feature.==classes[1], :, 1);
    else
        # Si hay mas de dos clases se devuelve una matriz con una columna por clase.
        oneHot = Array{Bool,2}(undef, length(feature), numClasses);
        for numClass = 1:numClasses
            oneHot[:,numClass] .= (feature.==classes[numClass]);
        end;
        matriz = oneHot;
    end;
    return matriz
end;

function oneHotEncoding(feature::AbstractArray{<:Any,1})
    classes = unique(feature)
    @assert(numClasses>1);
    if numClasses==2
        # Si solo hay dos clases, se devuelve una matriz con una columna.
        matriz_una_columna = reshape(feature.==classes[1], :, 1);
    else
        # Si hay mas de dos clases se devuelve una matriz con una columna por clase.
        oneHot = Array{Bool,2}(undef, length(feature), numClasses);
        for numClass = 1:numClasses
            oneHot[:,numClass] .= (feature.==classes[numClass]);
        end;
        matriz = oneHot;
    end;
    return matriz
end;

function oneHotEncoding(feature::AbstractArray{Bool,1})
    matriz_una_columna = reshape(feature, :, 1)
    return matriz_una_columna
end;

# Crear un vector de ejemplo con valores booleanos
feature_bool = [true, false, true, true, false]

# Probar la función oneHotEncoding para un único parámetro feature de tipo AbstractArray{Bool,1}
matriz_resultante = oneHotEncoding(feature_bool)
println("Matriz resultante para la función oneHotEncoding con un solo parámetro:")
println(matriz_resultante)

# Crear un vector de ejemplo con valores de diferentes clases
feature_clases = ["A", "B", "A", "C", "B", "C"]

# Probar la función oneHotEncoding para dos parámetros feature y classes de tipo AbstractArray{<:Any,1}
matriz_resultante = oneHotEncoding(feature_clases, unique(feature_clases))
println("\nMatriz resultante para la función oneHotEncoding con dos parámetros:")
println(matriz_resultante)























function calculateMinMaxNormalizationParameters(dataset::AbstractArray{<:Real,2})


function calculateZeroMeanNormalizationParameters(dataset::AbstractArray{<:Real,2})


function normalizeMinMax!(dataset::AbstractArray{<:Real,2},

 normalizationParameters::NTuple{2, AbstractArray{<:Real,2}})


function normalizeMinMax!(dataset::AbstractArray{<:Real,2})


function normalizeMinMax( dataset::AbstractArray{<:Real,2},

 normalizationParameters::NTuple{2, AbstractArray{<:Real,2}})


function normalizeMinMax( dataset::AbstractArray{<:Real,2})


function normalizeZeroMean!(dataset::AbstractArray{<:Real,2},

 normalizationParameters::NTuple{2, AbstractArray{<:Real,2}})


function normalizeZeroMean!(dataset::AbstractArray{<:Real,2})


function normalizeZeroMean( dataset::AbstractArray{<:Real,2},

 normalizationParameters::NTuple{2, AbstractArray{<:Real,2}})


function normalizeZeroMean( dataset::AbstractArray{<:Real,2})


function classifyOutputs(outputs::AbstractArray{<:Real,1}; threshold::Real=0.5)


function classifyOutputs(outputs::AbstractArray{<:Real,2}; threshold::Real=0.5)


function accuracy(outputs::AbstractArray{Bool,1}, targets::AbstractArray{Bool,1})


function accuracy(outputs::AbstractArray{Bool,2}, targets::AbstractArray{Bool,2})


function accuracy(outputs::AbstractArray{<:Real,1}, targets::AbstractArray{Bool,1};

 threshold::Real=0.5)

function accuracy(outputs::AbstractArray{<:Real,2}, targets::AbstractArray{Bool,2};

 threshold::Real=0.5)


function buildClassANN(numInputs::Int, topology::AbstractArray{<:Int,1}, numOutputs::Int;

 transferFunctions::AbstractArray{<:Function,1}=fill(σ, length(topology)))


function trainClassANN(topology::AbstractArray{<:Int,1},

 dataset::Tuple{AbstractArray{<:Real,2}, AbstractArray{Bool,2}};

 transferFunctions::AbstractArray{<:Function,1}=fill(σ, length(topology)),

 maxEpochs::Int=1000, minLoss::Real=0.0, learningRate::Real=0.01)


function trainClassANN(topology::AbstractArray{<:Int,1},

 (inputs, targets)::Tuple{AbstractArray{<:Real,2}, AbstractArray{Bool,1}};

 transferFunctions::AbstractArray{<:Function,1}=fill(σ, length(topology)),
 
 maxEpochs::Int=1000, minLoss::Real=0.0, learningRate::Real=0.01)